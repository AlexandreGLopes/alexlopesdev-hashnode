---
title: "Princípios do SOLID"
slug: principios-do-solid
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1717855308771/1340a354-713e-4a7f-8acd-9ea8eb0ce438.jpeg

---

SOLID é um acrônimo para os cinco princípios definidos por Michael Feathers a partir do Clean Code de Robert C. Martin. A ideia por trás desses princípios é definir claramente as boas práticas para deixar um software flexível e adaptável mais facilmente, ajudando a evitar a introdução de bugs no seu processo de manutenção e expansão.

Os princípios são:

1. ### SRP: Single Responsibility Principle
    
    Princípio da Responsabilidade Única: uma classe ou uma função/método deve ter um, e somente um, motivo para mudar. Ou seja, uma classe, método ou função deve ter um propósito único e claro.  
    Vejamos um exemplo:
    
    ```csharp
    public class UserAccountService
    {
        public void CreateUser(string username, string password)
        {
            Console.WriteLine("User created");
            ActivateUserAndSendEmail(username, "Welcome to our system!");
        }
    
        public void ActivateUserAndSendEmail(User user, string message)
        {
            user.isActive = true;
            Console.WriteLine("User is now activated");
    
            Console.WriteLine($"Email sent to {user.username}: {message}");
        }
    }
    ```
    
    No exemplo acima vemos que temos uma classe com duas responsabilidades distintas. Uma delas seria a criação de um usuário e a outra a ativação e notificação via e-mail desse processo. Perceba que até o método de notificar está com duas responsabilidades diferentes.  
    Temos alguns problemas que resultam disso: (1) *falta de coesão*, pois ela só vem quando os vários métodos da classe são voltados a uma mesma ideia; (2) *alto acoplamento*, pois quanto mais responsabilidades maior nível de engessamento do código, podendo ter mais bugs quando for alterado; (3) *dá mais trabalho para construir testes automatizados*, pois o "mock" é muito cheio de dependências; (4) *fica mais difícil para reaproveitar o código*.  
    Para respeitar esse princípio devemos separar essas responsabilidades em duas classes diferentes:
    
    ```csharp
    public interface IUserAccountService
    {
        bool CreateUser(string username, string password);
        bool ActivateUser(int id);
    }
    
    public class UserAccountService : IUserAccountService
    {
        public bool CreateUser(string username, string password)
        {
            Console.WriteLine("User created");
            return true;
        }
    
        public bool ActivateUser(int id)
        {
            Console.WriteLine("User activated");
            return true;
        }
    }
    
    public interface IEmailService
    {
        void SendEmail(string to, string message);
    }
    
    public class EmailService : IEmailService
    {
        public void SendEmail(string to, string message)
        {
            Console.WriteLine($"Email sent to {to}: {message}");
        }
    }
    ```
    
    Aqui nós acabamos por deixar na classe de usuário suas responsabilidades correspondentes e na classe de e-mail também. Criamos também interfaces das quais essas classes implementam métodos para essas interfaces sejam chamadas e não as classes concretas.
    
2. ### OCP: Open-Closed Principle
    
    Princípio Aberto-Fechado: Objetos ou entidades devem estar abertos para extensão, mas fechados para modificação, ou seja, quando novos comportamentos e recursos precisam ser adicionados no software, devemos extender e não alterar o código fonte original. (Open-Closed Principle também é base para o padrão de projeto Strategy)
    
    A partir daqui começaremos a ver que cada princípio vai dependendo e se cruzando com os outros.
    
    Vamos passar ao exemplo. Imagine um sistema de pagamentos:
    
    ```csharp
    public class PaymentProcessor 
    {
        public void Process(string type) 
        {
            if (type == "CREDIT") 
            {
                Console.WriteLine($"Processing payment in Credit Card");
            }
            else if (type == "DEBIT")
            {
                Console.WriteLine($"Processing payment in Debit Card");
            }
    }
    ```
    
    Neste caso, toda vez que formos acrescentar uma nova forma de pagamento estaremos introduzindo uma mudança no código da classe que os processa. O exemplo está simples, mas caso o código fique mais complexo acabaremos por aumentar esses “if/else”s deixando eles cada vez mais aninhados, deixando o código mais difícil de ler, aumentando a chance de bugs e dificultando a resolução deles.
    
    Há várias formas de resolver isso, mas uma das mais fáceis para exemplo é: *implementar uma interface para o comportamento extensível e inverter a dependência*.
    
    Por fim poderíamos fazer assim:
    
    ```csharp
    interface IPaymentType 
    {
        void Process();
    }
    
    public class CreditCard : IPaymentType
    {
        public void Process() 
        {
            Console.WriteLine($"Processing payment in Credit Card");
        }
    }
    
    public class DebitCard: IPaymentType
    {
        public void Process() 
        {
            Console.WriteLine($"Processing payment in Debit Card");
        }
    }
    
    public class Cash: IPaymentType
    {
        public void Process() 
        {
            Console.WriteLine($"Processing payment in Cash");
        }
    }
    
    public class PaymentProcessor 
    {
        public void Process(IPaymentType type) 
        {
            type.Process();
        }
    }
    ```
    
    Agora a classe de processar pagamentos não conhece os detalhes de cada um dos tipos diferentes de pagamentos possíveis. Cartões de crédito tem certas validações que um método de pagamento em dinheiro ou boleto não têm, por exemplo. Cada imlpementação da interface de tipo de pagamento é que sabe como deve proceder para efetivar essa tarefa.
    
    E cada nova adição de tipo de pagamento novo pode ser feita simplesmente adicionando uma nova classe que implementa PaymentType, sem mexer em nada na classe de PaymentProcessor.
    
    Isso já conclui nossa introdução ao OCP em si mesmo. Mas, vamos fazer um adendo. É preciso notar algo importante: ELE NÃO VAI ELIMINAR OS “IF/ELSES” DO SEU CÓDIGO. Note que esse formato vai passar a estrutura de decisão de qual classe e implementação de pagamento será utilizada para outra classe. E, respeitando o SRP, a melhor forma de fazer isso é criar uma classe especializada. Essa classe definidora será chamada por um controller ou um service que, após a definição da implentação de método de pagamento a ser usada, vai faz a chamada do processamento.
    
    Como exemplo bônus, vamos dizer que tenhamos escolhido construir uma classe de Simple Factory para essa função:
    
    ```csharp
    public class PaymentDTO
    {
        public string PaymentType { get; set; }
        public decimal Value { get; set; }
        public string CardNumber { get; set; }
        public string EmailPayPal { get; set; }
    }
    
    public interface IPaymentTypeFactory
    {
        IPaymentType Create(string paymentType);
    }
    
    public class PaymentTypeFactory: IPaymentTypeFactory
    {
        private readonly Dictionary<string, Func<PaymentDTO, IPaymentType>> _factories;
        
        public PaymentTypeFactory()
        {
            _factories = new Dictionary<string, Func<PaymentDTO, IPaymentType>>
            {
                ["CREDITO"] = dto => new CreditCard(dto.CardNumber, dto.Value),
                ["DEBITO"] = dto => new DebitCard(dto.CardNumber, dto.Value),
                ["PAYPAL"] = dto => new PayPal(dto.EmailPayPal, dto.Value),
                ["PIX"] = dto => new Cash(dto.Value)
            };
        }
        
        public IPaymentType Create(PagamentoDTO dto)
        {
            if (_factories.TryGetValue(dto.PaymentType.ToUpper(), out var factory))
            {
                return factory(dto);
            }
            
            throw new ArgumentException($"Payment Method not supported: {dto.PaymentType}");
        }
    }
    ```
    
    O exemplo acima serve para caso tenhamos como objetivo usar IPaymentTypeFactory com inversão de controle (IoC). Mas, também é possível pensar numa classe de Factory mais simples com um switch para a definição:
    
    ```csharp
    public static class PaymentTypeFactory
    {
        public static PaymentType Create(PaymentDTO dto)
        {
            return dto.PaymentType?.ToUpper() switch
            {
                "CREDITO" => new CreditCard(dto.CardNumber, dto.Value),
                "DEBITO" => new DebitCard(dto.CardNumber, dto.Value),
                "PAYPAL" => new PayPal(dto.EmailPayPal, dto.Value),
                "PIX" => new Cash(dto.Value),
                _ => throw new ArgumentException($"Payment Method not supported: {dto.PaymentType}")
            };
        }
    }
    ```
    
    Perceba que o OCP não te dá uma “varinha mágica” que elimina as necessidades de estruturas de decisões (if-else, switch-case, dictionary como consulta), mas ele te força a organizar melhor seu código a ponto de tornar mais ágil a adição de novos recursos.
    
3. ### LSP: Liskov Substitution Principle
    
    Este princípio foi definido por Barbara Liskov e ele diz que “subclasses devem poder ser substutídas por suas classes base sem quebrar o programa”. Basicamente, é um princípio que nos força a usar o pilar da herança da forma mais correta possível.
    
    Com o passar do tempo, notou-se que a teoria formal dos contratos de Bertrand Meyer servia como um ótimo manual de como garatir o LSP. E para isso, ela estabelece três diretrizes:
    
    * **Pré-condição**: a subclasse não pode exigir mais do que a classe base exigia.
        
    * **Pós-condição**: a subclasse não pode reduzir as garantias fornecidas pela classe base após a execução do método.
        
    * **Invariância**: a subclasse não pode alterar as condições que a classe base mantinha constantes.
        
    
    Veja os seguintes exemplos:
    
    ```csharp
    public class Classroom 
    { 
        public void startClassSession(int studentsNumber) 
        {
            if (studentsNumber < 1)
                throw new ArgumentException("Must be at least one student to start session");
        }
    }
    
    public class PrimaryClassroom : Classroom 
    { 
        public void startClassSession(int studentsNumber) 
        {
            if (studentsNumber < 5)
                throw new ArgumentException("Must be at least one student to start session");
        }
    }
    
    class Program
    {
        static void Main()
        {
            int studentsQuantity = 1;
            
            // instanciando Classroom como no linha abaixo não vai dar problema algum.
            // Classroom classroom = new Classroom();
            // Mas como exemplo agora vamos trocar e classroom passará a ser do tipo filho.
            // E agora teremos uma exception
            PrimaryClassroom classroom = new PrimaryClassroom();
            
            classroom.startClassSession(studentsQuantity);
            //Dá esception porque 1 é menor que 5 no caso do PrimaryClassroom 
        }
    }
    ```
    
    No exemplo acima estamos quebrando a diretriz da pré-condição. Estamos exigindo que para iniciar uma aula do primário tenhamos mais alunos do que a classe pai de aula exigia a princípio. Pré-condições não podem ser fortalecidas. Se não, quando trocarmos a classe de “aula” por uma classe de “aula do primário”, o código que antes não estava dando exceção para ninciar uma aula com 1 aluno agora vai dar. E teremos que tratar isso com IF/ELSES no código que está chamando os métodos de startClassSession, e isso vai quebrar o OCP e o DIP do SOLID.
    
    Para resolver isso temos que usar a herança de forma mais correta:
    
    ```csharp
    public abstract class Classroom 
    { 
        public abstract void startClassSession(int studentsNumber);
    }
    
    public class PrimaryClassroom : Classroom 
    { 
        public void startClassSession(int studentsNumber) 
        {
            if (studentsNumber < 5)
                throw new ArgumentException("Must be at least one student to start session");
        }
    }
    
    public class FundamentalClassroom : Classroom 
    { 
        public void startClassSession(int studentsNumber) 
        {
            if (studentsNumber < 1)
                throw new ArgumentException("Must be at least one student to start session");
        }
    }
    ```
    
    Agora temos duas classes reais que implementam uma classe abstrata mais genérica. Resolvemos o problema de ter criado uma classe genérica anterior de maneira errada. E resolvemos também o problema de fortalecer erroneamente as validações dessa classe base, exigindo mais do que ela exigia. Utilzamos no caso uma classe abstrata mas poderíamos ter utilizado uma interface para obrgar as classes a implementar contratos.
    
    No caso da pós-condição podemos dar os seguintes exemplos:
    
    ```csharp
    class UploadFile
    {
        public virtual bool UploadFileToS3(IFormFile file)
        {
            Console.WriteLine("Uploading to S3...");
            return true;
        }
    }
    
    class UploadFileApi : UploadFile
    {
        public new Dictionary<string, object> UploadFileToS3(IFormFile file)
        {
            Console.WriteLine("Uploading via API...");
            
            return new Dictionary<string, object>
            {
                ["auth"] = true,
                ["status"] = 201,
                ["message"] = "Created"
            };
        }
    }
    
    class Program
    {
        static void Main()
        {
            // instancia ou recebe o UploadFile de algum lugar
            
            if (uploadFile is UploadFileApi apiUploader)
            {
                apiUploader.UploadFileToS3(file);
                // faz alguma coisa
            }
    
            uploadFile.UploadFileToS3(file);
            // faz alguma coisa
        }
    }
    ```
    
    Perceba que estamos retornando duas respostas diferentes sobrescrevendo o método UploadFileToS3 nesse exemplo. E mais uma vez estamos forçando que o módulo que chama o método UploadFileToS3 conheça os detalhes desse método e lide com as possíveis respostas dele por meio de IF/ELSEs.
    
    Vejamos mais um exemplo. Desta vez, sobre a diretriz de invarância:
    
    ```csharp
    public class BankAccount
    {
        protected decimal balance;
        
        public virtual void Withdraw(decimal amount)
        {   
            if (amount > balance)
                throw new ArgumentException("Withdraw must not be higher than balance");
                
            balance -= amount;
    
            if (balance < 0) 
                throw new Exception("Invariant violated!");
        }
    }
    
    public class CurrentAccount : BankAccount
    {
        protected decimal overdraftLimit;
    
        public override void Withdraw(decimal amount)
        {
            if (amount > (balance + overdraftLimit))
                throw new ArgumentException("Withdraw must not be higher than balance plus overdraft limit");
                
            balance -= amount;
        }
    }
    
    class Program
    {
        static void Main()
        {
            BankAccount account = new CurrentAccount();
            account.GetBalance(); // Vamos assumir que é 100
            
            // Com BankAccount normal: Lançaria exceção
            // Com CurrentAccount: Permite (mas quebra invariante)
            account.Withdraw(150);
        }
    }
    ```
    
    Neste caso estamos quebrando a regra da invariância porque antes a classe pai não permitia que o saldo da conta fosse negativo. Mas agora, com a conta corrente não temos mais a exception sendo lançada. Agora vão haver saçdos negativos. E todos os códigos que dependiam dessa regra de um saldo nunca negativo também vão quebrar.
    
    Em síntese, podemos dar três regras do que se PODE e do que NÃO SE PODE fazer.
    
    Você PODE sobrescrever métodos SE:
    
    * Adicionar comportamento.
        
    * Fornecer implementação específica mantendo o contrato.
        
    * Lançar exceções MAIS ESPECÍFICAS (não mais genéricas).
        
    
    Você NÃO DEVE sobrescrever métodos SE:
    
    * Mudar as regras de validação (fortalecer pré-condições).
        
    * Reduzir o que o método promete (enfraquecer pós-condições).
        
    * Quebrar "garantias" que a classe base dava.
        
    
4. ### ISP: Interface Segregation Principle